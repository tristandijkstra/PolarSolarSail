'''
node.py

This model computes equilibrium temperatures and thermal balances for the solar orbiter spacecraft. The code is
just a loop that goes through each shielding condition, each thermal condition, and each node of the spacecraft
to print out equilibrium temperatures and thermal balances.

Some key assumptions:
    - This is technically 2 separate single node analyses for the spacecraft, rather than a 2 node analysis. This is
    because the view factor between the solar sails and the spacecraft bus is assumed to be negligible, as is conductive
    contact due to the lack of mechanical booms.
        - The two separate nodes are thus the spacecraft bus (with heat shield), and the solar sails.
    - Solar cells were not considered at this phase of design in this model.
    - Conductive transfer in the interface between the shield and spacecraft was also not considered, and was assumed small
    through the use of potential thermal isolation techniques.

TODO:
    - Add more nodes for better localization of heat and cold centres in the model.
    - Add temporal changes to the thermal model based on the orbital model (can use animations if we would like to showoff)
    - Migrate this to software such as ANSYS for analysis once a 3D model is created.

'''

import pandas as pd
import numpy as np


class Node():
    def __init__(self, name, properties, case, n_shield=0, nodes=1):
        '''
        This sets up each Node class with the surface properties and the area.
        
        Inputs:
        
        name [str]: The name of the node
        skin_properties [arr]: Input an array consisting of [emissivity, absorptivity, reflectivity, radiator_emissivity], all scaled from 0 to 1.
        area [arr]: Input an array consisting of [area that the sun sees, area that deep space sees, area covered by radiators.]
        case [arr]: Input an array consisting of [distance in AU, angle from sun in rad]
        n_shield [int]: The number of layers for the heat shield.
        '''
        self.name = name
        self.emissivity = properties[0]
        self.absorptivity = properties[1]
        self.reflectivity = properties[2]
        self.density = properties[3]
        self.area = properties[4]
        self.distance = case[0]
        self.angle = case[1]
        self.SB = 5.67e-8
        self.solar_luminosity = 3.83e26
        self.n_shield = n_shield
        self.nodes = nodes
    
    def solar_heat_in(self):
        '''
        This computes the solar heat that the outer surface sees.

        The formula is Q = A * (L * a * cos(theta) / (4 * PI * R^2))
            - A = area of surface accepting Sun's heat [m^2]
            - L = luminosity [W] 
            - a = absorptivity
            - theta = angle to the Sun (0 is such that the spacecraft is facing the sun directly)
            - R = distance from Sun [m]
        
        Outputs:
        
        self.solar_q_in [float]: Incoming heat from the sun in W.
        '''
        self.solar_flux = (np.cos(self.angle) * self.solar_luminosity * self.absorptivity) / (4 * np.pi * (self.distance * 1.496e11)**2)
        self.solar_q_in = self.solar_flux * self.area
        return self.solar_q_in
    
    def internal_heat(self, heater_power, electrical_heat):
        '''
        This computes the heat generated inside the spacecraft.

        Inputs:
            - heater_power [W]
            - electrical_heat [W]
        
        Outputs:
        
            self.q_interal [float]: Internal heat generated by the spacecraft in W
        '''
        self.q_internal = heater_power + electrical_heat
        return self.q_internal

    def heat_absorbed(self, eq_temp):
        '''
        Computes the heat absorbed by a certain surface.

        The formula is Q = A * a * sigma * T^4
            - A = area of surface
            - a = absorptivity of the surface
            - sigma = stefan-boltzmann constant
            - T = surface temperature

        Inputs:
            - eq_temp [K]: The equilibrium temperature of the surface (calculated using temperatures())
        
        Outputs:
        
            self.q_absorbed [float]: The total heat absorbed by the node.
        '''
        self.q_absorbed = self.absorptivity * self.SB * self.area * eq_temp**4
        return self.q_absorbed

    def heat_radiated(self, eq_temp):
        '''
        Computes the heat radiated by a certain surface.

        The formula is Q = A * e * sigma * T^4
            - A = area of surface
            - e = emissivity of the surface
            - sigma = stefan-boltzmann constant
            - T = surface temperature

        Inputs:
            - eq_temp [K]: The equilibrium temperature of the surface (calculated using temperatures())
        
        Outputs:
        
            self.q_radiated [float]: The total heat radiated by the node.
        '''
        self.q_radiated = self.emissivity * self.SB * self.area * eq_temp**4
        return self.q_radiated

    def thermal_balance(self):
        '''
        Computes the thermal balance of the node.

        Inputs:
        
        Outputs:
        
            self.q_absorbed - self.q_radiated [float]: The thermal balance of the node.
        '''
        return self.q_absorbed - self.q_radiated
    
    

def temperatures(bus, sail, shield):
    '''
        Computes the equilibrium temperatures for each node.

        For the shield, it does this using the concept of thermal resistance. In the absence
        of shielding, the heat added to the spacecraft wall is equal to the inputted solar heat 
        plus the internal heat of the spacecraft, while the heat lost is from radiation to deep
        space. 

        q_internal + solar_q_in = A * e * sigma * T_wall^4.
        
        T_wall can be solved in this equation to get the wall equilibrium temperature.

        When shielding is added, there is also an interaction between the shield wall and the 
        spacecraft wall. This shielding reduces the solar heat felt by the spacecraft wall by
        a factor of:

        1 / ((n_shields / e_shield) + (1 / e_wall) - n_shields)

        Information for this part of the model was modified from information about the radiation
        felt between a series of parallel plates. It had to be modified as the sun is not a parallel 
        plate. However, the heat shield and spacecraft were assumed to be parallel plates for this 
        analysis (which may not be true in practice).

        Sources:
            https://thermopedia.com/content/69/
            https://web.mit.edu/16.unified/www/FALL/thermodynamics/notes/node136.html
            https://www.engineeringenotes.com/thermal-engineering/heat-transfer/use-of-radiation-shields-to-reduce-heat-transfer-thermal-engineering/30727

        Inputs:
        - bus [class]: The Node object corresponding to the spacecraft bus.
        - sail [class]: The Node object corresponding to the solar sail.
        - shield [class]: The Node object corresponding to the heat shield
        
        Outputs:
        
            self.q_absorbed - self.q_radiated [float]: The thermal balance of the node.
        '''
    if shield != None:
        therm_resistance = ((shield.n_shield / shield.emissivity) + (1 / bus.emissivity) - shield.n_shield)
        temp_bus = ((bus.q_internal + (bus.solar_q_in / therm_resistance)) / ((bus.area * bus.emissivity * bus.SB) + (bus.emissivity_rad * bus.SB * bus.area)))**(1/4)
        term_4 = ((bus.area / shield.area) * temp_bus**4)
        term_5 = shield.solar_q_in * ((1/shield.emissivity) + (1/bus.emissivity) - 1)
        term_6 = shield.SB * shield.area_space
        temp_shield = (term_4 + (term_5 / term_6))**(1/4)
    else:
        q_int = bus.q_internal
        q_solar = bus.solar_q_in
        temp_bus = ((q_int + q_solar) / ((bus.emissivity * bus.SB * bus.area_space) + (bus.emissivity_rad * bus.SB * bus.area_radiator)))**(1/4)
        temp_shield = np.nan

    temp_sail = ((sail.solar_q_in) / ((sail.reflectivity + sail.emissivity)*sail.area_space*sail.SB))**(1/4)

    return temp_bus, temp_shield, temp_sail

